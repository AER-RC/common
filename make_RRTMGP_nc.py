#!/usr/bin/env python

from __future__ import print_function

import os, sys, glob, argparse
import numpy as np
import netCDF4 as nc

# this module was eventually moved to externals/common
#sys.path.append('externals/common')
import utils
import RC_utils as RC

class configSetup():
  def __init__(self, inFile):
    """
    Parse the input .ini file (inFile) and return as a dictionary for 
    use in the rest of this module

    Inputs
      inFile -- string, full path to .ini file that specifies ...

    Keywords
      doSW -- boolean, process shortwave instead of longwave
    """

    utils.file_check(inFile)

    # standard library, but name depends on Python version
    if sys.version_info.major < 3:
      import ConfigParser
    else:
      import configparser as ConfigParser
    # endif Python version

    cParse = ConfigParser.ConfigParser()
    cParse.read(inFile)
    cpSections = cParse.sections()

    # loop over each field (of all sections) and keep the field and 
    # associated value in returned object (self)
    for iCPS, cps in enumerate(cpSections):
      cItems = cParse.items(cps)
      for item in cItems: setattr(self, item[0], item[1])
    # end sections loop

  # end constructor
# end configSetup()

class swRRTMGP():
  def __init__(self, config):
    """
    Class that conforms all of profiles generated by the SW Flux 
    Calculation software to the RRTMGP netCDF convention

    Input
      config -- configSetup object

    Keywords
    """

    paths = [config.top, config.nctemplate]
    for path in paths: utils.file_check(path)

    # gather all output directories that correspond to the working 
    # directories generated in SW_create_inputs.py/SW_calc_fluxes.py
    search = '%s/%s/*.nc' % (config.top, config.subdirstr)
    profNC = sorted(glob.glob(search))
    self.profiles = profNC
    self.tempNC = config.nctemplate
    self.id = config.id
    self.specs = config.specs

    # for the new netCDF; we'll assume all profNC have same dimensions
    self.nProf = len(profNC)
    ncObj = nc.Dataset(profNC[0], 'r')
    self.nLev = ncObj.dimensions['levels'].size
    self.nLay = self.nLev - 1
    ncObj.close()

    # bands will remain unchanged
    ncObj = nc.Dataset(self.tempNC, 'r')
    self.bands = np.array(ncObj.variables['band_lims_wvn'])
    self.nBands = self.bands.shape[0]
    ncObj.close()
    
    self.base = os.path.basename(self.tempNC)

    subStr = 'sw'
    newSub = '%s-%s' % (subStr, self.id)
    if 'sw' in self.base:
      self.outFile = self.base.replace(subStr, newSub)
    else:
      self.outFile = '%s_%s' % (newSub, self.base)
    # endif base

    # these three attribute lists have elements that correspond to 
    # each other ('down_direct' : 'band_flux_dir_dn' : 'flux_dir_dn')
    # but there's no reason to have RRTMGP wavenumbers because of 
    # self.bands
    self.fluxVars = ['down_direct', 'down_diffuse', \
      'down_total', 'up_total', 'net_flux', 'wavenumber']
    self.rrtmgpVars = ['band_flux_dir_dn', 'band_flux_dif_dn', \
      'band_flux_dn', 'band_flux_up', 'band_flux_net', '']
    self.rrtmgpVarsBB = ['flux_dir_dn', 'flux_dif_dn', \
      'flux_dn', 'flux_up', 'flux_net', '']
  # end constructor()

  def initializeNC(self):
    """
    Using the netCDF template, start a netCDF that will contain the 
    fields from the RRTMGP netCDF but will be stuffed with fluxes as 
    calculated with the SW Flux Calculation library

    the template is expected to follow the 
    rrtmgp-??-inputs-outputs-*.nc convention, where ?? is either "lw"
    or "sw"
    """

    print('Building %s' % self.outFile)

    inObj = nc.Dataset(self.tempNC, 'r')
    outObj = nc.Dataset(self.outFile, 'w')

    # for RRTMGP, we only have 5 dimensions, but lev, lay, and col
    # will probably be different in the SW flux calc output
    dims = inObj.dimensions
    for dim in dims:
      dimName = dims[dim].name
      if dimName == 'lev':
        dimSize = self.nLev
      elif dimName == 'lay':
        dimSize = self.nLay
      elif dimName == 'col':
        dimSize = self.nProf
      else:
        dimSize = dims[dim].size
      # endif dim.name

      outObj.createDimension(dim, dimSize)
    # end dim loop

    # unchanged, necessary variables from template
    inVar = inObj.variables['band_lims_wvn']
    outVar = outObj.createVariable(\
      inVar.name, inVar.dtype, inVar.dimensions)
    outVar.units = 'cm-1'
    outVar[:] = np.array(inVar)

    # there is no band dependence on pressures, so store them now
    inVarLev = inObj.variables['p_lev']
    inVarLay = inObj.variables['p_lay']
    if self.specs != '':
      specsObj = nc.Dataset(self.specs)
      pLev = np.array(specsObj.variables['pres_level'])
      pLay = np.array(specsObj.variables['pres_layer'])
      pUnits = specsObj.variables['pres_level'].units
      specsObj.close()

      # right now, i don't have all of the RFMIP profile results, 
      # so slice what i do have
      outVarLev = outObj.createVariable(\
        inVarLev.name, inVarLev.dtype, inVarLev.dimensions)
      outVarLev.units = pUnits
      outVarLev[:] = pLev.T[:, :self.nProf]

      outVarLay = outObj.createVariable(\
        inVarLay.name, inVarLay.dtype, inVarLay.dimensions)
      outVarLay.units = pUnits
      outVarLay[:] = pLay.T[:, :self.nProf]
    else:
      # fill these in eventually
      pLev = np.zeros((self.nLev, self.nProf))
      pLay = np.zeros((self.nLay, self.nProf))
      pUnits = 'mbar'
    # endif specs

    # and now the variables that will change
    keys = self.fluxVars
    for iKey, key in enumerate(keys):
      if key == 'wavenumber': continue
      inVar = inObj.variables[self.rrtmgpVars[iKey]]
      inVarBB = inObj.variables[self.rrtmgpVarsBB[iKey]]

      outVar = outObj.createVariable(\
        inVar.name, inVar.dtype, inVar.dimensions)
      outVar.units = inVar.units
      outVarBB = outObj.createVariable(\
        inVarBB.name, inVarBB.dtype, inVarBB.dimensions)
      outVarBB.units = inVarBB.units
    # end keep loop

    # heating rates
    inVar = inObj.variables['band_heating_rate']
    outVar = outObj.createVariable(\
      inVar.name, inVar.dtype, inVar.dimensions)
    outVar.units = inVar.units

    inVarBB = inObj.variables['heating_rate']
    outVarBB = outObj.createVariable(\
      inVarBB.name, inVarBB.dtype, inVarBB.dimensions)
    outVarBB.units = inVarBB.units

    inObj.close()
    outObj.close()

    return self
  # end initializeNC()

  def combineArr(self):
    """
    Combine flux arrays from SW Flux Calculation output files
    """

    # expected variable names
    keys = self.fluxVars

    # first make lists of flux and wavenumber arrays
    profDict = {}
    for key in keys: profDict[key] = []

    for prof in self.profiles:
      inObj = nc.Dataset(prof, 'r')

      for var in (inObj.variables):
        if var not in keys: continue
        profDict[var].append(np.array(inObj.variables[var]))
      # end var loop

      inObj.close()
    # end profile loop

    # wavenumber arrays should be identical
    ref = profDict['wavenumber'][0]
    for i in range(1, self.nProf):
      test = profDict['wavenumber'][i]
      errMsg = 'Wavenumbers for Experiments 1 and %d ' % (i+1) + \
        'are inconsistent, returning'
      if not np.all(ref == test): sys.exit(errMsg)
    # end profile loop

    # and since wavenumber arrays are identical (now), only need 1
    profDict['wavenumber'] = np.array(ref)

    # rearrange the flux arrays to match RRTMGP convenvtion of 
    # nLev x nProf x nBand and set appropriate attribute in object
    newDim = (1, 0, 2)
    for key in keys:
      newArr = np.array(profDict[key])
      if key == 'wavenumber':
        setattr(self, key, newArr)
      else:
        setattr(self, key, np.transpose(newArr, newDim))
      # endif key
    # end key loop
  # end combineArr()

  def computeBands(self, broadband=False):
    """
    Compute fluxes for each RRTMGP-defined band

    Keywords
      broadband -- boolean, calculate broadband instead of by-band 
        fluxes
    """

    wnArr = self.wavenumber
    keys = self.fluxVars
    fluxDict = {}

    if broadband:
      for iKey, key in enumerate(keys):
        if key == 'wavenumber': continue
        fluxArr = getattr(self, key)
        fluxDict[key] = fluxArr[:, :, :].sum(axis=2)
      # end key loop

      rrtmgpVars = self.rrtmgpVarsBB
    else:
      for key in keys: fluxDict[key] = \
        np.zeros((self.nLev, self.nProf, self.nBands))

      for iBand, band in enumerate(self.bands):
        # the SW flux calculation should go down to 100 cm-1
        # but the lowest wavenumber in RRTMGP is 820; we wanna include
        # all SW radiation, so we'll extend the first band as low as 
        # we can
        if iBand == 0:
          cond = wnArr < band[1]
        else:
          cond = (wnArr >= band[0]) & (wnArr < band[1])
        # endif band

        for key in keys:
          if key == 'wavenumber': continue
          fluxArr = getattr(self, key)
          fluxDict[key][:, :, iBand] = fluxArr[:, :, cond].sum(axis=2)
        # end key loop
      # end band loop

      rrtmgpVars = self.rrtmgpVars

    # endif BB

    # now add arrays to netCDF
    outObj = nc.Dataset(self.outFile, 'r+')
    for iKey, key in enumerate(keys):
      if key == 'wavenumber': continue
      outVar = outObj.variables[rrtmgpVars[iKey]]
      outVar[:] = fluxDict[key]
    # end keep loop

    # heating rates calculations (not entirely sure if my method is 
    # correct...)
    if broadband:
      outVarBB = outObj.variables['heating_rate']
      diff = np.array(outObj.variables['flux_dn']) - \
        np.array(outObj.variables['flux_up'])
      outVarBB[:] = RC.fluxToHR(diff)
      outObj.close()
    else:
      outVar = outObj.variables['band_heating_rate']
      diff = np.array(outObj.variables['band_flux_dn']) - \
        np.array(outObj.variables['band_flux_up'])
      outVar[:] = RC.fluxToHR(diff)
    # endif BB
  # end computeBands()
# end ncRRTMGP()

if __name__ == '__main__':
  parser = argparse.ArgumentParser(\
    description='Reorganize the output from the SW Flux ' + \
    'Calculation library -- which produces a subdirectory ' + \
    'for every processed profile and an associated netCDF ' + \
    'with flux spectra underneath the subdir -- into a single ' + \
    'netCDF that conforms to the RRTMGP convention so that ' + \
    'fluxes and heating rates for two models (e.g., LBLRTM vs. ' + \
    'RRTMGP) can be compared. NOTE: right now, the code is ' + \
    'optimized to handle RFMIP profiles and has not been tested ' + \
    'with other (e.g., Garand) specifications.')
  parser.add_argument('--ini_file', '-ini', type=str, \
    default='sw_make_RRTMGP_nc.ini', \
    help='Configuration file with specs for ncRRTMGP class.' )
  args = parser.parse_args()

  iniFile = args.ini_file
  ini = configSetup(iniFile)
  ncRRTMGP = swRRTMGP(ini)
  ncRRTMGP.initializeNC()
  ncRRTMGP.combineArr()
  ncRRTMGP.computeBands()
  ncRRTMGP.computeBands(broadband=True)

# end main()

